#!/usr/bin/env python3
"""
Realtime Voice Chat Server
This file is automatically generated from server_part*.py files.
Do not edit this file directly.
"""

# Imports
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any, Union
from typing import Dict, List, Optional, Any, Union, Tuple
import aiohttp
import asyncio
import base64
import dotenv
import io
import json
import logging
import numpy as np
import os
import sys
import time
import uuid
import websockets

# Part 1: server_part1.py
#!/usr/bin/env python3
"""
Realtime Voice Chat Server - Part 1: Core and Configuration
"""


















# Load environment variables
dotenv.load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("voice-chat-server")

# Configuration
PORT = int(os.getenv("PORT", "8000"))
HOST = os.getenv("HOST", "0.0.0.0")

# Service URLs
VAD_SERVICE_URL = os.getenv("VAD_SERVICE_URL", "http://vad:3001")
STT_SERVICE_URL = os.getenv("STT_SERVICE_URL", "http://stt:3002")
TTS_SERVICE_URL = os.getenv("TTS_SERVICE_URL", "http://tts:3003")
LLM_SERVICE_URL = os.getenv("LLM_SERVICE_URL", "http://llm:3004")
OLLAMA_SERVICE_URL = os.getenv("OLLAMA_SERVICE_URL", "http://ollama:11434")

# Create FastAPI app
app = FastAPI(title="Realtime Voice Chat Server")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# HTTP client session
http_session = None

# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        
    async def connect(self, websocket: WebSocket, client_id: str):
        await websocket.accept()
        self.active_connections[client_id] = websocket
        logger.info(f"Client {client_id} connected. Total connections: {len(self.active_connections)}")
        
    def disconnect(self, client_id: str):
        if client_id in self.active_connections:
            del self.active_connections[client_id]
            logger.info(f"Client {client_id} disconnected. Total connections: {len(self.active_connections)}")
    
    async def send_text(self, client_id: str, message: str):
        if client_id in self.active_connections:
            await self.active_connections[client_id].send_text(message)
    
    async def send_bytes(self, client_id: str, data: bytes):
        if client_id in self.active_connections:
            await self.active_connections[client_id].send_bytes(data)
    
    async def send_json(self, client_id: str, data: dict):
        if client_id in self.active_connections:
            await self.active_connections[client_id].send_json(data)
    
    async def broadcast_text(self, message: str, exclude: Optional[str] = None):
        for client_id, connection in self.active_connections.items():
            if exclude is None or client_id != exclude:
                await connection.send_text(message)
    
    async def broadcast_json(self, data: dict, exclude: Optional[str] = None):
        for client_id, connection in self.active_connections.items():
            if exclude is None or client_id != exclude:
                await connection.send_json(data)

# Create connection manager
manager = ConnectionManager()

# Session data store
class SessionStore:
    def __init__(self):
        self.sessions: Dict[str, Dict[str, Any]] = {}
    
    def create_session(self, client_id: str) -> Dict[str, Any]:
        """Create a new session for a client."""
        session = {
            "client_id": client_id,
            "created_at": time.time(),
            "conversation": [],
            "is_speaking": False,
            "last_activity": time.time(),
            "audio_buffer": bytearray(),
            "transcription_buffer": "",
            "response_audio_queue": asyncio.Queue(),
        }
        self.sessions[client_id] = session
        return session
    
    def get_session(self, client_id: str) -> Optional[Dict[str, Any]]:
        """Get a session by client ID."""
        return self.sessions.get(client_id)
    
    def update_session(self, client_id: str, data: Dict[str, Any]) -> None:
        """Update a session with new data."""
        if client_id in self.sessions:
            self.sessions[client_id].update(data)
            self.sessions[client_id]["last_activity"] = time.time()
    
    def delete_session(self, client_id: str) -> None:
        """Delete a session."""
        if client_id in self.sessions:
            del self.sessions[client_id]
    
    def cleanup_old_sessions(self, max_age_seconds: int = 3600) -> None:
        """Clean up sessions older than max_age_seconds."""
        now = time.time()
        to_delete = []
        for client_id, session in self.sessions.items():
            if now - session["last_activity"] > max_age_seconds:
                to_delete.append(client_id)
        
        for client_id in to_delete:
            self.delete_session(client_id)
            logger.info(f"Cleaned up inactive session for client {client_id}")

# Create session store
session_store = SessionStore()

# Service health check
async def check_service_health(url: str) -> bool:
    """Check if a service is healthy."""
    try:
        async with http_session.get(f"{url}/healthz", timeout=2) as response:
            return response.status == 200
    except Exception as e:
        logger.warning(f"Health check failed for {url}: {e}")
        return False

# Startup event
@app.on_event("startup")
async def startup_event():
    """Initialize resources on startup."""
    global http_session
    
    # Create HTTP session
    http_session = aiohttp.ClientSession()
    
    # Check service health
    services = [
        ("VAD", VAD_SERVICE_URL),
        ("STT", STT_SERVICE_URL),
        ("TTS", TTS_SERVICE_URL),
        ("LLM", LLM_SERVICE_URL),
    ]
    
    for name, url in services:
        is_healthy = await check_service_health(url)
        logger.info(f"{name} service health: {'OK' if is_healthy else 'FAIL'}")

# Shutdown event
@app.on_event("shutdown")
async def shutdown_event():
    """Clean up resources on shutdown."""
    if http_session:
        await http_session.close()

# Health check endpoint
@app.get("/healthz")
async def health_check():
    """Health check endpoint."""
    return {"status": "ok"}

# Home page
@app.get("/", response_class=HTMLResponse)
async def get_home():
    """Serve the home page."""
    with open("static/index.html", "r") as f:
        return f.read()

# API endpoints
class SystemInfoResponse(BaseModel):
    services: Dict[str, bool]
    active_connections: int
    uptime: float

@app.get("/api/system-info", response_model=SystemInfoResponse)
async def get_system_info():
    """Get system information."""
    # Check service health
    services = {
        "vad": await check_service_health(VAD_SERVICE_URL),
        "stt": await check_service_health(STT_SERVICE_URL),
        "tts": await check_service_health(TTS_SERVICE_URL),
        "llm": await check_service_health(LLM_SERVICE_URL),
    }
    
    return {
        "services": services,
        "active_connections": len(manager.active_connections),
        "uptime": time.time() - startup_time,
    }

# Store startup time
startup_time = time.time()

def main():
    """Run the server."""
    import uvicorn
    uvicorn.run(app, host=HOST, port=PORT)

# Part 2: server_part2.py
#!/usr/bin/env python3
"""
Realtime Voice Chat Server - Part 2: Audio Processing and Speech Recognition
"""






# Audio processing constants
SAMPLE_RATE = 16000
CHUNK_SIZE = 4096  # 256ms at 16kHz

# Audio processing functions
async def process_audio_chunk(client_id: str, audio_chunk: bytes) -> None:
    """Process an audio chunk from a client."""
    session = session_store.get_session(client_id)
    if not session:
        logger.warning(f"No session found for client {client_id}")
        return
    
    # Add chunk to buffer
    session["audio_buffer"].extend(audio_chunk)
    
    # Check if we have enough data for VAD
    if len(session["audio_buffer"]) >= CHUNK_SIZE * 2:  # At least 512ms of audio
        # Detect voice activity
        is_speaking = await detect_voice_activity(client_id, bytes(session["audio_buffer"]))
        
        # Update session
        session_store.update_session(client_id, {"is_speaking": is_speaking})
        
        # If speaking, transcribe audio
        if is_speaking:
            # Keep accumulating audio for better transcription
            if len(session["audio_buffer"]) >= SAMPLE_RATE * 2:  # 2 seconds of audio
                # Transcribe audio
                transcription = await transcribe_audio(client_id, bytes(session["audio_buffer"]))
                
                # If we got a transcription, clear buffer
                if transcription:
                    session["audio_buffer"] = bytearray()
        else:
            # Not speaking, check if we have accumulated transcription
            if session["transcription_buffer"]:
                # Process transcription
                await process_transcription(client_id, session["transcription_buffer"])
                
                # Clear transcription buffer
                session_store.update_session(client_id, {"transcription_buffer": ""})
            
            # Clear audio buffer if not speaking
            session["audio_buffer"] = bytearray()

async def detect_voice_activity(client_id: str, audio_data: bytes) -> bool:
    """
    Detect voice activity in audio data using the VAD service.
    
    Args:
        client_id: Client ID
        audio_data: Audio data as bytes
        
    Returns:
        True if voice activity detected, False otherwise
    """
    try:
        # Prepare form data
        form_data = aiohttp.FormData()
        form_data.add_field("file", io.BytesIO(audio_data), filename="audio.raw")
        
        # Send request to VAD service
        async with http_session.post(f"{VAD_SERVICE_URL}/detect", data=form_data) as response:
            if response.status != 200:
                logger.warning(f"VAD service returned status {response.status}")
                return False
            
            # Parse response
            result = await response.json()
            
            # Check if speech segments were detected
            speech_segments = result.get("speech_segments", [])
            is_speaking = len(speech_segments) > 0
            
            # Log result
            if is_speaking:
                logger.debug(f"Voice activity detected for client {client_id}")
            
            return is_speaking
    except Exception as e:
        logger.error(f"Error detecting voice activity: {e}")
        return False

async def transcribe_audio(client_id: str, audio_data: bytes) -> Optional[str]:
    """
    Transcribe audio data using the STT service.
    
    Args:
        client_id: Client ID
        audio_data: Audio data as bytes
        
    Returns:
        Transcription text or None if failed
    """
    try:
        # Prepare form data
        form_data = aiohttp.FormData()
        form_data.add_field("file", io.BytesIO(audio_data), filename="audio.raw")
        form_data.add_field("language", "en")
        
        # Send request to STT service
        async with http_session.post(f"{STT_SERVICE_URL}/transcribe", data=form_data) as response:
            if response.status != 200:
                logger.warning(f"STT service returned status {response.status}")
                return None
            
            # Parse response
            result = await response.json()
            
            # Extract transcription
            text = result.get("text", "").strip()
            
            # If we got text, update session
            if text:
                session = session_store.get_session(client_id)
                if session:
                    # Append to transcription buffer
                    current_buffer = session.get("transcription_buffer", "")
                    if current_buffer:
                        current_buffer += " "
                    current_buffer += text
                    
                    # Update session
                    session_store.update_session(client_id, {"transcription_buffer": current_buffer})
                    
                    # Log transcription
                    logger.info(f"Transcription for client {client_id}: {text}")
                    
                    # Send transcription to client
                    await manager.send_json(client_id, {
                        "type": "transcription",
                        "text": text,
                        "is_final": result.get("is_final", False)
                    })
            
            return text
    except Exception as e:
        logger.error(f"Error transcribing audio: {e}")
        return None

async def process_transcription(client_id: str, text: str) -> None:
    """
    Process a transcription from a client.
    
    Args:
        client_id: Client ID
        text: Transcription text
    """
    session = session_store.get_session(client_id)
    if not session:
        logger.warning(f"No session found for client {client_id}")
        return
    
    # Add user message to conversation
    session["conversation"].append({
        "role": "user",
        "content": text
    })
    
    # Generate response
    response = await generate_response(client_id, session["conversation"])
    
    # If we got a response, add it to conversation and synthesize speech
    if response:
        # Add assistant message to conversation
        session["conversation"].append({
            "role": "assistant",
            "content": response
        })
        
        # Synthesize speech
        await synthesize_speech(client_id, response)

# WebSocket endpoint for audio streaming
@app.websocket("/ws/audio")
async def websocket_audio(websocket: WebSocket):
    """WebSocket endpoint for audio streaming."""
    # Generate client ID
    client_id = str(uuid.uuid4())
    
    # Accept connection
    await manager.connect(websocket, client_id)
    
    # Create session
    session = session_store.create_session(client_id)
    
    # Create task for sending TTS audio
    tts_task = asyncio.create_task(send_tts_audio(client_id))
    
    try:
        # Send client ID to client
        await websocket.send_json({"type": "client_id", "client_id": client_id})
        
        # Process incoming audio chunks
        while True:
            # Receive audio chunk
            audio_chunk = await websocket.receive_bytes()
            
            # Process audio chunk
            await process_audio_chunk(client_id, audio_chunk)
    except WebSocketDisconnect:
        logger.info(f"Client {client_id} disconnected")
    except Exception as e:
        logger.error(f"Error in WebSocket connection: {e}")
    finally:
        # Clean up
        manager.disconnect(client_id)
        session_store.delete_session(client_id)
        tts_task.cancel()
        try:
            await tts_task
        except asyncio.CancelledError:
            pass

async def send_tts_audio(client_id: str) -> None:
    """
    Send TTS audio to a client.
    
    Args:
        client_id: Client ID
    """
    session = session_store.get_session(client_id)
    if not session:
        logger.warning(f"No session found for client {client_id}")
        return
    
    try:
        while True:
            # Get audio from queue
            audio_data = await session["response_audio_queue"].get()
            
            # Send audio to client
            await manager.send_bytes(client_id, audio_data)
            
            # Mark task as done
            session["response_audio_queue"].task_done()
    except asyncio.CancelledError:
        logger.info(f"TTS audio task cancelled for client {client_id}")
    except Exception as e:
        logger.error(f"Error sending TTS audio: {e}")

# Part 3: server_part3.py
#!/usr/bin/env python3
"""
Realtime Voice Chat Server - Part 3: LLM Response Generation and TTS
"""





# System prompt for LLM
SYSTEM_PROMPT = """You are a helpful voice assistant. 
Provide concise, accurate responses to user queries.
Keep your responses conversational but brief, as they will be spoken aloud.
"""

async def generate_response(client_id: str, conversation: List[Dict[str, str]]) -> Optional[str]:
    """
    Generate a response using the LLM service.
    
    Args:
        client_id: Client ID
        conversation: Conversation history
        
    Returns:
        Generated response or None if failed
    """
    try:
        # Prepare conversation with system prompt
        messages = [{"role": "system", "content": SYSTEM_PROMPT}]
        messages.extend(conversation)
        
        # Prepare request data
        request_data = {
            "messages": messages,
            "temperature": 0.7,
            "stream": False
        }
        
        # Send request to LLM service
        async with http_session.post(f"{LLM_SERVICE_URL}/generate", json=request_data) as response:
            if response.status != 200:
                logger.warning(f"LLM service returned status {response.status}")
                return None
            
            # Parse response
            result = await response.json()
            
            # Extract text
            text = result.get("text", "").strip()
            
            # Log response
            if text:
                logger.info(f"LLM response for client {client_id}: {text[:100]}{'...' if len(text) > 100 else ''}")
                
                # Send response to client
                await manager.send_json(client_id, {
                    "type": "response",
                    "text": text
                })
            
            return text
    except Exception as e:
        logger.error(f"Error generating response: {e}")
        return None

async def synthesize_speech(client_id: str, text: str) -> None:
    """
    Synthesize speech using the TTS service.
    
    Args:
        client_id: Client ID
        text: Text to synthesize
    """
    try:
        # Prepare request data
        request_data = {
            "text": text,
            "language": "en",
            "return_format": "wav"
        }
        
        # Send request to TTS service
        async with http_session.post(f"{TTS_SERVICE_URL}/synthesize", json=request_data) as response:
            if response.status != 200:
                logger.warning(f"TTS service returned status {response.status}")
                return
            
            # Get audio data
            audio_data = await response.read()
            
            # Get session
            session = session_store.get_session(client_id)
            if not session:
                logger.warning(f"No session found for client {client_id}")
                return
            
            # Add audio to queue
            await session["response_audio_queue"].put(audio_data)
            
            # Log synthesis
            logger.info(f"Synthesized speech for client {client_id}: {len(audio_data)} bytes")
    except Exception as e:
        logger.error(f"Error synthesizing speech: {e}")

# WebSocket endpoint for text chat
@app.websocket("/ws/chat")
async def websocket_chat(websocket: WebSocket):
    """WebSocket endpoint for text chat."""
    # Generate client ID
    client_id = str(uuid.uuid4())
    
    # Accept connection
    await manager.connect(websocket, client_id)
    
    # Create session
    session = session_store.create_session(client_id)
    
    try:
        # Send client ID to client
        await websocket.send_json({"type": "client_id", "client_id": client_id})
        
        # Process incoming messages
        while True:
            # Receive message
            data = await websocket.receive_json()
            
            # Extract message
            message = data.get("message", "").strip()
            
            # Process message
            if message:
                # Process transcription
                await process_transcription(client_id, message)
    except WebSocketDisconnect:
        logger.info(f"Client {client_id} disconnected")
    except Exception as e:
        logger.error(f"Error in WebSocket connection: {e}")
    finally:
        # Clean up
        manager.disconnect(client_id)
        session_store.delete_session(client_id)

# API endpoint for text chat
class ChatRequest(BaseModel):
    message: str

@app.post("/api/chat")
async def chat(request: ChatRequest):
    """
    Chat API endpoint.
    
    Args:
        request: Chat request
        
    Returns:
        Chat response
    """
    # Generate client ID
    client_id = str(uuid.uuid4())
    
    # Create session
    session = session_store.create_session(client_id)
    
    try:
        # Process message
        message = request.message.strip()
        if not message:
            raise HTTPException(status_code=400, detail="Message cannot be empty")
        
        # Add user message to conversation
        session["conversation"].append({
            "role": "user",
            "content": message
        })
        
        # Generate response
        response = await generate_response(client_id, session["conversation"])
        
        # If we got a response, add it to conversation
        if response:
            # Add assistant message to conversation
            session["conversation"].append({
                "role": "assistant",
                "content": response
            })
            
            # Return response
            return {"response": response}
        else:
            raise HTTPException(status_code=500, detail="Failed to generate response")
    finally:
        # Clean up
        session_store.delete_session(client_id)

# API endpoint for speech synthesis
class SynthesisRequest(BaseModel):
    text: str
    language: str = "en"
    voice: Optional[str] = None
    return_format: str = "wav"  # "wav" or "base64"

@app.post("/api/synthesize")
async def synthesize(request: SynthesisRequest):
    """
    Speech synthesis API endpoint.
    
    Args:
        request: Synthesis request
        
    Returns:
        Synthesized speech
    """
    try:
        # Prepare request data
        request_data = {
            "text": request.text,
            "language": request.language,
            "voice": request.voice,
            "return_format": request.return_format
        }
        
        # Send request to TTS service
        async with http_session.post(f"{TTS_SERVICE_URL}/synthesize", json=request_data) as response:
            if response.status != 200:
                logger.warning(f"TTS service returned status {response.status}")
                raise HTTPException(status_code=response.status, detail="TTS service error")
            
            # Get content type
            content_type = response.headers.get("Content-Type", "application/octet-stream")
            
            # Get audio data
            audio_data = await response.read()
            
            # Return audio data
            if request.return_format == "base64":
                # Parse JSON response
                result = await response.json()
                return result
            else:
                # Return WAV data
                return Response(content=audio_data, media_type=content_type)
    except Exception as e:
        logger.error(f"Error synthesizing speech: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Periodic tasks
async def periodic_tasks():
    """Run periodic tasks."""
    while True:
        try:
            # Clean up old sessions
            session_store.cleanup_old_sessions()
            
            # Wait for next run
            await asyncio.sleep(3600)  # Run every hour
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Error in periodic tasks: {e}")
            await asyncio.sleep(60)  # Wait a bit before retrying

# Start periodic tasks
@app.on_event("startup")
async def start_periodic_tasks():
    """Start periodic tasks."""
    asyncio.create_task(periodic_tasks())

if __name__ == "__main__":
    main()
